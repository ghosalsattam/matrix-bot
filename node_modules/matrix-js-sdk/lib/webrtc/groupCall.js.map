{"version":3,"file":"groupCall.js","names":["_typedEventEmitter","require","_callFeed","_call","_roomState","_logger","_ReEmitter","_callEventTypes","_event","_callEventHandler","_groupCallEventHandler","_utils","_groupCallStats","_statsReport","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty2","default","getOwnPropertyDescriptors","defineProperties","defineProperty","GroupCallIntent","exports","GroupCallType","GroupCallTerminationReason","GroupCallEvent","GroupCallStatsReportEvent","GroupCallErrorCode","GroupCallError","Error","constructor","code","msg","err","GroupCallUnknownDeviceError","userId","UnknownDevice","OtherUserSpeakingError","GroupCallState","DEVICE_TIMEOUT","getCallUserId","call","_call$getOpponentMemb","getOpponentMember","invitee","GroupCall","TypedEventEmitter","client","room","type","isPtt","intent","groupCallId","dataChannelsEnabled","dataChannelOptions","isCallWithoutVideoAndAudio","_room$currentState$ge","_room$currentState$ge2","Map","report","emit","ConnectionStats","ByteSentStats","LocalCallFeedUninitialized","newCall","_newCall$getOpponentM","_this$calls$get","roomId","state","CallState","Ringing","logger","warn","log","reject","opponentUserId","undefined","deviceMap","calls","get","prevCall","getOpponentDeviceId","callId","hangup","CallErrorCode","Replaced","initCall","feeds","getLocalFeeds","map","feed","clone","callExpected","setTracksEnabled","stream","getAudioTracks","getVideoTracks","answerWithCallFeeds","set","CallsChanged","needsRetry","participantMap","participants","callMap","retriesMap","retryCallCounts","deviceId","participant","_retriesMap$get","_retriesMap","retries","getOpponentSessionId","sessionId","wantsOutgoingCall","placeOutgoingCalls","opponentMemberId","opponentDeviceId","currentUserMediaFeed","getUserMediaFeed","remoteUsermediaFeed","remoteFeedChanged","addUserMediaFeed","replaceUserMediaFeed","removeUserMediaFeed","currentScreenshareFeed","getScreenshareFeed","remoteScreensharingFeed","remoteScreenshareFeedChanged","addScreenshareFeed","replaceScreenshareFeed","removeScreenshareFeed","_oldState","_call$getOpponentMemb2","Ended","audioMuted","localCallFeed","isAudioMuted","localUsermediaStream","isMicrophoneMuted","setMicrophoneMuted","videoMuted","isVideoMuted","isLocalVideoMuted","setLocalVideoMuted","Connected","delete","size","_call$getOpponentMemb3","_call$getOpponentMemb4","hangupReason","getMember","disposeCall","topAvg","nextActiveSpeaker","callFeed","userMediaFeeds","isLocal","total","speakingVolumeSamples","reduce","acc","volume","Math","max","SPEAKING_THRESHOLD","avg","activeSpeaker","ActiveSpeakerChanged","updateParticipants","forEachCall","expected","Entered","newState","oldState","updateMemberState","catch","e","error","reEmitter","ReEmitter","genCallID","creationTs","currentState","getStateEvents","EventType","GroupCallPrefix","getTs","on","RoomStateEvent","Update","onRoomState","ParticipantsChanged","onParticipantsChanged","GroupCallStateChanged","onStateChanged","LocalScreenshareStateChanged","onLocalFeedsChanged","allowCallWithoutVideoAndAudio","userID","getUserId","stats","GroupCallStats","reports","StatsReport","CONNECTION_STATS","onConnectionStats","BYTE_SENT_STATS","onByteSentStats","create","Date","now","groupCallEventHandler","groupCalls","GroupCallEventHandlerEvent","Outgoing","groupCallState","sendStateEvent","_state","value","prevValue","_participants","participantStateEqual","x","y","screensharing","deviceMapsEqual","mapsEqual","_creationTs","enteredViaAnotherSession","_enteredViaAnotherSession","f","values","localScreenshareFeed","hasLocalParticipant","_this$participants$ge","_this$participants$ge2","has","getDeviceId","_this$participants$ge3","member","initLocalCallFeed","InitializingLocalCallFeed","initCallFeedPromise","initLocalCallFeedInternal","getMediaHandler","getUserMediaStream","Video","MediaStream","stopUserMediaStream","CallFeed","purpose","SDPStreamMetadataPurpose","Usermedia","initWithAudioMuted","initWithVideoMuted","LocalCallFeedInitialized","updateLocalUsermediaStream","oldStream","setNewStream","micShouldBeMuted","vidShouldBeMuted","id","enter","CallEventHandlerEvent","Incoming","onIncomingCall","callEventHandler","retryCallLoopInterval","setInterval","onRetryCallLoop","retryCallInterval","onActiveSpeakerLoop","activeSpeakerLoopInterval","activeSpeakerInterval","dispose","stopScreensharingStream","localDesktopCapturerSourceId","stopAllStreams","transmitTimer","clearTimeout","clearInterval","participantsExpirationTimer","UserHangup","clear","removeListener","stop","leave","terminate","emitStateEvent","off","existingStateEvent","getContent","CallEnded","muted","hasAudioDevice","sendUpdatesBefore","setTimeout","pttMaxTransmitTime","_call$localUsermediaF","localUsermediaFeed","setAudioVideoMuted","sendUpdates","updates","sendMetadataUpdate","Promise","all","info","LocalMuteStateChanged","hasVideoDevice","_","setScreensharingEnabled","enabled","opts","isScreensharing","getScreensharingStream","track","getTracks","onTrackEnded","removeEventListener","addEventListener","desktopCapturerSourceId","Screenshare","pushLocalFeed","throwOnFail","NoUserMedia","localScreensharingFeed","removeLocalFeed","localUserId","localDeviceId","callsChanged","_this$calls$get2","debug","NewSession","createNewMatrixCall","opponentSessionId","placeCallWithCallFeeds","then","createDataChannel","CallError","PlaceCallFailed","SignallingFailed","getMemberStateEvents","GroupCallMemberPrefix","onCallFeedsChanged","onCallStateChanged","onCallHangup","onCallReplaced","callHandlers","CallEvent","FeedsChanged","State","Hangup","reEmit","initStats","usermediaFeed","screenshareFeed","find","measureVolumeActivity","UserMediaFeedsChanged","existingFeed","replacementFeed","feedIndex","findIndex","splice","screenshareFeeds","ScreenshareFeedsChanged","localMember","entered","nextExpiration","Infinity","getStateKey","content","Array","isArray","devices","validDevices","d","device_id","session_id","expires_ts","membership","some","getSessionId","updateDevices","fn","keepAlive","_event$getContent","event","otherCalls","c","newDevices","newCalls","newContent","addDeviceToMemberState","resendMemberStateTimer","cleanMemberState","myDevices","getDevices","device","last_seen_ts","getGroupCallStats"],"sources":["../../src/webrtc/groupCall.ts"],"sourcesContent":["import { TypedEventEmitter } from \"../models/typed-event-emitter\";\nimport { CallFeed, SPEAKING_THRESHOLD } from \"./callFeed\";\nimport { MatrixClient, IMyDevice } from \"../client\";\nimport {\n    CallErrorCode,\n    CallEvent,\n    CallEventHandlerMap,\n    CallState,\n    genCallID,\n    MatrixCall,\n    setTracksEnabled,\n    createNewMatrixCall,\n    CallError,\n} from \"./call\";\nimport { RoomMember } from \"../models/room-member\";\nimport { Room } from \"../models/room\";\nimport { RoomStateEvent } from \"../models/room-state\";\nimport { logger } from \"../logger\";\nimport { ReEmitter } from \"../ReEmitter\";\nimport { SDPStreamMetadataPurpose } from \"./callEventTypes\";\nimport { MatrixEvent } from \"../models/event\";\nimport { EventType } from \"../@types/event\";\nimport { CallEventHandlerEvent } from \"./callEventHandler\";\nimport { GroupCallEventHandlerEvent } from \"./groupCallEventHandler\";\nimport { IScreensharingOpts } from \"./mediaHandler\";\nimport { mapsEqual } from \"../utils\";\nimport { GroupCallStats } from \"./stats/groupCallStats\";\nimport { ByteSentStatsReport, ConnectionStatsReport, StatsReport } from \"./stats/statsReport\";\n\nexport enum GroupCallIntent {\n    Ring = \"m.ring\",\n    Prompt = \"m.prompt\",\n    Room = \"m.room\",\n}\n\nexport enum GroupCallType {\n    Video = \"m.video\",\n    Voice = \"m.voice\",\n}\n\nexport enum GroupCallTerminationReason {\n    CallEnded = \"call_ended\",\n}\n\nexport type CallsByUserAndDevice = Map<string, Map<string, MatrixCall>>;\n\n/**\n * Because event names are just strings, they do need\n * to be unique over all event types of event emitter.\n * Some objects could emit more then one set of events.\n */\nexport enum GroupCallEvent {\n    GroupCallStateChanged = \"group_call_state_changed\",\n    ActiveSpeakerChanged = \"active_speaker_changed\",\n    CallsChanged = \"calls_changed\",\n    UserMediaFeedsChanged = \"user_media_feeds_changed\",\n    ScreenshareFeedsChanged = \"screenshare_feeds_changed\",\n    LocalScreenshareStateChanged = \"local_screenshare_state_changed\",\n    LocalMuteStateChanged = \"local_mute_state_changed\",\n    ParticipantsChanged = \"participants_changed\",\n    Error = \"group_call_error\",\n}\n\nexport type GroupCallEventHandlerMap = {\n    [GroupCallEvent.GroupCallStateChanged]: (newState: GroupCallState, oldState: GroupCallState) => void;\n    [GroupCallEvent.ActiveSpeakerChanged]: (activeSpeaker: CallFeed | undefined) => void;\n    [GroupCallEvent.CallsChanged]: (calls: CallsByUserAndDevice) => void;\n    [GroupCallEvent.UserMediaFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.ScreenshareFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.LocalScreenshareStateChanged]: (\n        isScreensharing: boolean,\n        feed?: CallFeed,\n        sourceId?: string,\n    ) => void;\n    [GroupCallEvent.LocalMuteStateChanged]: (audioMuted: boolean, videoMuted: boolean) => void;\n    [GroupCallEvent.ParticipantsChanged]: (participants: Map<RoomMember, Map<string, ParticipantState>>) => void;\n    /**\n     * Fires whenever an error occurs when call.js encounters an issue with setting up the call.\n     * <p>\n     * The error given will have a code equal to either `MatrixCall.ERR_LOCAL_OFFER_FAILED` or\n     * `MatrixCall.ERR_NO_USER_MEDIA`. `ERR_LOCAL_OFFER_FAILED` is emitted when the local client\n     * fails to create an offer. `ERR_NO_USER_MEDIA` is emitted when the user has denied access\n     * to their audio/video hardware.\n     * @param err - The error raised by MatrixCall.\n     * @example\n     * ```\n     * matrixCall.on(\"error\", function(err){\n     *   console.error(err.code, err);\n     * });\n     * ```\n     */\n    [GroupCallEvent.Error]: (error: GroupCallError) => void;\n};\n\nexport enum GroupCallStatsReportEvent {\n    ConnectionStats = \"GroupCall.connection_stats\",\n    ByteSentStats = \"GroupCall.byte_sent_stats\",\n}\n\nexport type GroupCallStatsReportEventHandlerMap = {\n    [GroupCallStatsReportEvent.ConnectionStats]: (report: GroupCallStatsReport<ConnectionStatsReport>) => void;\n    [GroupCallStatsReportEvent.ByteSentStats]: (report: GroupCallStatsReport<ByteSentStatsReport>) => void;\n};\n\nexport enum GroupCallErrorCode {\n    NoUserMedia = \"no_user_media\",\n    UnknownDevice = \"unknown_device\",\n    PlaceCallFailed = \"place_call_failed\",\n}\n\nexport interface GroupCallStatsReport<T extends ConnectionStatsReport | ByteSentStatsReport> {\n    report: T;\n}\n\nexport class GroupCallError extends Error {\n    public code: string;\n\n    public constructor(code: GroupCallErrorCode, msg: string, err?: Error) {\n        // Still don't think there's any way to have proper nested errors\n        if (err) {\n            super(msg + \": \" + err);\n        } else {\n            super(msg);\n        }\n\n        this.code = code;\n    }\n}\n\nexport class GroupCallUnknownDeviceError extends GroupCallError {\n    public constructor(public userId: string) {\n        super(GroupCallErrorCode.UnknownDevice, \"No device found for \" + userId);\n    }\n}\n\nexport class OtherUserSpeakingError extends Error {\n    public constructor() {\n        super(\"Cannot unmute: another user is speaking\");\n    }\n}\n\nexport interface IGroupCallDataChannelOptions {\n    ordered: boolean;\n    maxPacketLifeTime: number;\n    maxRetransmits: number;\n    protocol: string;\n}\n\nexport interface IGroupCallRoomState {\n    \"m.intent\": GroupCallIntent;\n    \"m.type\": GroupCallType;\n    \"io.element.ptt\"?: boolean;\n    // TODO: Specify data-channels\n    \"dataChannelsEnabled\"?: boolean;\n    \"dataChannelOptions\"?: IGroupCallDataChannelOptions;\n}\n\nexport interface IGroupCallRoomMemberFeed {\n    purpose: SDPStreamMetadataPurpose;\n}\n\nexport interface IGroupCallRoomMemberDevice {\n    device_id: string;\n    session_id: string;\n    expires_ts: number;\n    feeds: IGroupCallRoomMemberFeed[];\n}\n\nexport interface IGroupCallRoomMemberCallState {\n    \"m.call_id\": string;\n    \"m.foci\"?: string[];\n    \"m.devices\": IGroupCallRoomMemberDevice[];\n}\n\nexport interface IGroupCallRoomMemberState {\n    \"m.calls\": IGroupCallRoomMemberCallState[];\n}\n\nexport enum GroupCallState {\n    LocalCallFeedUninitialized = \"local_call_feed_uninitialized\",\n    InitializingLocalCallFeed = \"initializing_local_call_feed\",\n    LocalCallFeedInitialized = \"local_call_feed_initialized\",\n    Entered = \"entered\",\n    Ended = \"ended\",\n}\n\nexport interface ParticipantState {\n    sessionId: string;\n    screensharing: boolean;\n}\n\ninterface ICallHandlers {\n    onCallFeedsChanged: (feeds: CallFeed[]) => void;\n    onCallStateChanged: (state: CallState, oldState: CallState | undefined) => void;\n    onCallHangup: (call: MatrixCall) => void;\n    onCallReplaced: (newCall: MatrixCall) => void;\n}\n\nconst DEVICE_TIMEOUT = 1000 * 60 * 60; // 1 hour\n\nfunction getCallUserId(call: MatrixCall): string | null {\n    return call.getOpponentMember()?.userId || call.invitee || null;\n}\n\nexport class GroupCall extends TypedEventEmitter<\n    GroupCallEvent | CallEvent | GroupCallStatsReportEvent,\n    GroupCallEventHandlerMap & CallEventHandlerMap & GroupCallStatsReportEventHandlerMap\n> {\n    // Config\n    public activeSpeakerInterval = 1000;\n    public retryCallInterval = 5000;\n    public participantTimeout = 1000 * 15;\n    public pttMaxTransmitTime = 1000 * 20;\n\n    public activeSpeaker?: CallFeed;\n    public localCallFeed?: CallFeed;\n    public localScreenshareFeed?: CallFeed;\n    public localDesktopCapturerSourceId?: string;\n    public readonly userMediaFeeds: CallFeed[] = [];\n    public readonly screenshareFeeds: CallFeed[] = [];\n    public groupCallId: string;\n    public readonly allowCallWithoutVideoAndAudio: boolean;\n\n    private readonly calls = new Map<string, Map<string, MatrixCall>>(); // user_id -> device_id -> MatrixCall\n    private callHandlers = new Map<string, Map<string, ICallHandlers>>(); // user_id -> device_id -> ICallHandlers\n    private activeSpeakerLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallCounts: Map<string, Map<string, number>> = new Map(); // user_id -> device_id -> count\n    private reEmitter: ReEmitter;\n    private transmitTimer: ReturnType<typeof setTimeout> | null = null;\n    private participantsExpirationTimer: ReturnType<typeof setTimeout> | null = null;\n    private resendMemberStateTimer: ReturnType<typeof setInterval> | null = null;\n    private initWithAudioMuted = false;\n    private initWithVideoMuted = false;\n    private initCallFeedPromise?: Promise<void>;\n\n    private readonly stats: GroupCallStats;\n\n    public constructor(\n        private client: MatrixClient,\n        public room: Room,\n        public type: GroupCallType,\n        public isPtt: boolean,\n        public intent: GroupCallIntent,\n        groupCallId?: string,\n        private dataChannelsEnabled?: boolean,\n        private dataChannelOptions?: IGroupCallDataChannelOptions,\n        isCallWithoutVideoAndAudio?: boolean,\n    ) {\n        super();\n        this.reEmitter = new ReEmitter(this);\n        this.groupCallId = groupCallId ?? genCallID();\n        this.creationTs =\n            room.currentState.getStateEvents(EventType.GroupCallPrefix, this.groupCallId)?.getTs() ?? null;\n        this.updateParticipants();\n\n        room.on(RoomStateEvent.Update, this.onRoomState);\n        this.on(GroupCallEvent.ParticipantsChanged, this.onParticipantsChanged);\n        this.on(GroupCallEvent.GroupCallStateChanged, this.onStateChanged);\n        this.on(GroupCallEvent.LocalScreenshareStateChanged, this.onLocalFeedsChanged);\n        this.allowCallWithoutVideoAndAudio = !!isCallWithoutVideoAndAudio;\n\n        const userID = this.client.getUserId() || \"unknown\";\n        this.stats = new GroupCallStats(this.groupCallId, userID);\n        this.stats.reports.on(StatsReport.CONNECTION_STATS, this.onConnectionStats);\n        this.stats.reports.on(StatsReport.BYTE_SENT_STATS, this.onByteSentStats);\n    }\n\n    private onConnectionStats = (report: ConnectionStatsReport): void => {\n        // @TODO: Implement data argumentation\n        this.emit(GroupCallStatsReportEvent.ConnectionStats, { report });\n    };\n\n    private onByteSentStats = (report: ByteSentStatsReport): void => {\n        // @TODO: Implement data argumentation\n        this.emit(GroupCallStatsReportEvent.ByteSentStats, { report });\n    };\n\n    public async create(): Promise<GroupCall> {\n        this.creationTs = Date.now();\n        this.client.groupCallEventHandler!.groupCalls.set(this.room.roomId, this);\n        this.client.emit(GroupCallEventHandlerEvent.Outgoing, this);\n\n        const groupCallState: IGroupCallRoomState = {\n            \"m.intent\": this.intent,\n            \"m.type\": this.type,\n            \"io.element.ptt\": this.isPtt,\n            // TODO: Specify data-channels better\n            \"dataChannelsEnabled\": this.dataChannelsEnabled,\n            \"dataChannelOptions\": this.dataChannelsEnabled ? this.dataChannelOptions : undefined,\n        };\n\n        await this.client.sendStateEvent(this.room.roomId, EventType.GroupCallPrefix, groupCallState, this.groupCallId);\n\n        return this;\n    }\n\n    private _state = GroupCallState.LocalCallFeedUninitialized;\n\n    /**\n     * The group call's state.\n     */\n    public get state(): GroupCallState {\n        return this._state;\n    }\n\n    private set state(value: GroupCallState) {\n        const prevValue = this._state;\n        if (value !== prevValue) {\n            this._state = value;\n            this.emit(GroupCallEvent.GroupCallStateChanged, value, prevValue);\n        }\n    }\n\n    private _participants = new Map<RoomMember, Map<string, ParticipantState>>();\n\n    /**\n     * The current participants in the call, as a map from members to device IDs\n     * to participant info.\n     */\n    public get participants(): Map<RoomMember, Map<string, ParticipantState>> {\n        return this._participants;\n    }\n\n    private set participants(value: Map<RoomMember, Map<string, ParticipantState>>) {\n        const prevValue = this._participants;\n        const participantStateEqual = (x: ParticipantState, y: ParticipantState): boolean =>\n            x.sessionId === y.sessionId && x.screensharing === y.screensharing;\n        const deviceMapsEqual = (x: Map<string, ParticipantState>, y: Map<string, ParticipantState>): boolean =>\n            mapsEqual(x, y, participantStateEqual);\n\n        // Only update if the map actually changed\n        if (!mapsEqual(value, prevValue, deviceMapsEqual)) {\n            this._participants = value;\n            this.emit(GroupCallEvent.ParticipantsChanged, value);\n        }\n    }\n\n    private _creationTs: number | null = null;\n\n    /**\n     * The timestamp at which the call was created, or null if it has not yet\n     * been created.\n     */\n    public get creationTs(): number | null {\n        return this._creationTs;\n    }\n\n    private set creationTs(value: number | null) {\n        this._creationTs = value;\n    }\n\n    private _enteredViaAnotherSession = false;\n\n    /**\n     * Whether the local device has entered this call via another session, such\n     * as a widget.\n     */\n    public get enteredViaAnotherSession(): boolean {\n        return this._enteredViaAnotherSession;\n    }\n\n    public set enteredViaAnotherSession(value: boolean) {\n        this._enteredViaAnotherSession = value;\n        this.updateParticipants();\n    }\n\n    /**\n     * Executes the given callback on all calls in this group call.\n     * @param f - The callback.\n     */\n    public forEachCall(f: (call: MatrixCall) => void): void {\n        for (const deviceMap of this.calls.values()) {\n            for (const call of deviceMap.values()) f(call);\n        }\n    }\n\n    public getLocalFeeds(): CallFeed[] {\n        const feeds: CallFeed[] = [];\n\n        if (this.localCallFeed) feeds.push(this.localCallFeed);\n        if (this.localScreenshareFeed) feeds.push(this.localScreenshareFeed);\n\n        return feeds;\n    }\n\n    public hasLocalParticipant(): boolean {\n        return (\n            this.participants.get(this.room.getMember(this.client.getUserId()!)!)?.has(this.client.getDeviceId()!) ??\n            false\n        );\n    }\n\n    /**\n     * Determines whether the given call is one that we were expecting to exist\n     * given our knowledge of who is participating in the group call.\n     */\n    private callExpected(call: MatrixCall): boolean {\n        const userId = getCallUserId(call);\n        const member = userId === null ? null : this.room.getMember(userId);\n        const deviceId = call.getOpponentDeviceId();\n        return member !== null && deviceId !== undefined && this.participants.get(member)?.get(deviceId) !== undefined;\n    }\n\n    public async initLocalCallFeed(): Promise<void> {\n        if (this.state !== GroupCallState.LocalCallFeedUninitialized) {\n            throw new Error(`Cannot initialize local call feed in the \"${this.state}\" state.`);\n        }\n        this.state = GroupCallState.InitializingLocalCallFeed;\n\n        // wraps the real method to serialise calls, because we don't want to try starting\n        // multiple call feeds at once\n        if (this.initCallFeedPromise) return this.initCallFeedPromise;\n\n        try {\n            this.initCallFeedPromise = this.initLocalCallFeedInternal();\n            await this.initCallFeedPromise;\n        } finally {\n            this.initCallFeedPromise = undefined;\n        }\n    }\n\n    private async initLocalCallFeedInternal(): Promise<void> {\n        logger.log(`GroupCall ${this.groupCallId} initLocalCallFeedInternal() running`);\n\n        let stream: MediaStream;\n\n        try {\n            stream = await this.client.getMediaHandler().getUserMediaStream(true, this.type === GroupCallType.Video);\n        } catch (error) {\n            // If is allowed to join a call without a media stream, then we\n            // don't throw an error here. But we need an empty Local Feed to establish\n            // a connection later.\n            if (this.allowCallWithoutVideoAndAudio) {\n                stream = new MediaStream();\n            } else {\n                this.state = GroupCallState.LocalCallFeedUninitialized;\n                throw error;\n            }\n        }\n\n        // The call could've been disposed while we were waiting, and could\n        // also have been started back up again (hello, React 18) so if we're\n        // still in this 'initializing' state, carry on, otherwise bail.\n        if (this._state !== GroupCallState.InitializingLocalCallFeed) {\n            this.client.getMediaHandler().stopUserMediaStream(stream);\n            throw new Error(\"Group call disposed while gathering media stream\");\n        }\n\n        const callFeed = new CallFeed({\n            client: this.client,\n            roomId: this.room.roomId,\n            userId: this.client.getUserId()!,\n            deviceId: this.client.getDeviceId()!,\n            stream,\n            purpose: SDPStreamMetadataPurpose.Usermedia,\n            audioMuted: this.initWithAudioMuted || stream.getAudioTracks().length === 0 || this.isPtt,\n            videoMuted: this.initWithVideoMuted || stream.getVideoTracks().length === 0,\n        });\n\n        setTracksEnabled(stream.getAudioTracks(), !callFeed.isAudioMuted());\n        setTracksEnabled(stream.getVideoTracks(), !callFeed.isVideoMuted());\n\n        this.localCallFeed = callFeed;\n        this.addUserMediaFeed(callFeed);\n\n        this.state = GroupCallState.LocalCallFeedInitialized;\n    }\n\n    public async updateLocalUsermediaStream(stream: MediaStream): Promise<void> {\n        if (this.localCallFeed) {\n            const oldStream = this.localCallFeed.stream;\n            this.localCallFeed.setNewStream(stream);\n            const micShouldBeMuted = this.localCallFeed.isAudioMuted();\n            const vidShouldBeMuted = this.localCallFeed.isVideoMuted();\n            logger.log(\n                `GroupCall ${this.groupCallId} updateLocalUsermediaStream() (oldStreamId=${oldStream.id}, newStreamId=${stream.id}, micShouldBeMuted=${micShouldBeMuted}, vidShouldBeMuted=${vidShouldBeMuted})`,\n            );\n            setTracksEnabled(stream.getAudioTracks(), !micShouldBeMuted);\n            setTracksEnabled(stream.getVideoTracks(), !vidShouldBeMuted);\n            this.client.getMediaHandler().stopUserMediaStream(oldStream);\n        }\n    }\n\n    public async enter(): Promise<void> {\n        if (this.state === GroupCallState.LocalCallFeedUninitialized) {\n            await this.initLocalCallFeed();\n        } else if (this.state !== GroupCallState.LocalCallFeedInitialized) {\n            throw new Error(`Cannot enter call in the \"${this.state}\" state`);\n        }\n\n        logger.log(`GroupCall ${this.groupCallId} enter() running`);\n        this.state = GroupCallState.Entered;\n\n        this.client.on(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n\n        for (const call of this.client.callEventHandler!.calls.values()) {\n            this.onIncomingCall(call);\n        }\n\n        this.retryCallLoopInterval = setInterval(this.onRetryCallLoop, this.retryCallInterval);\n\n        this.activeSpeaker = undefined;\n        this.onActiveSpeakerLoop();\n        this.activeSpeakerLoopInterval = setInterval(this.onActiveSpeakerLoop, this.activeSpeakerInterval);\n    }\n\n    private dispose(): void {\n        if (this.localCallFeed) {\n            this.removeUserMediaFeed(this.localCallFeed);\n            this.localCallFeed = undefined;\n        }\n\n        if (this.localScreenshareFeed) {\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n        }\n\n        this.client.getMediaHandler().stopAllStreams();\n\n        if (this.transmitTimer !== null) {\n            clearTimeout(this.transmitTimer);\n            this.transmitTimer = null;\n        }\n\n        if (this.retryCallLoopInterval !== undefined) {\n            clearInterval(this.retryCallLoopInterval);\n            this.retryCallLoopInterval = undefined;\n        }\n\n        if (this.participantsExpirationTimer !== null) {\n            clearTimeout(this.participantsExpirationTimer);\n            this.participantsExpirationTimer = null;\n        }\n\n        if (this.state !== GroupCallState.Entered) {\n            return;\n        }\n\n        this.forEachCall((call) => call.hangup(CallErrorCode.UserHangup, false));\n\n        this.activeSpeaker = undefined;\n        clearInterval(this.activeSpeakerLoopInterval);\n\n        this.retryCallCounts.clear();\n        clearInterval(this.retryCallLoopInterval);\n\n        this.client.removeListener(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n        this.stats.stop();\n    }\n\n    public leave(): void {\n        this.dispose();\n        this.state = GroupCallState.LocalCallFeedUninitialized;\n    }\n\n    public async terminate(emitStateEvent = true): Promise<void> {\n        this.dispose();\n\n        this.room.off(RoomStateEvent.Update, this.onRoomState);\n        this.client.groupCallEventHandler!.groupCalls.delete(this.room.roomId);\n        this.client.emit(GroupCallEventHandlerEvent.Ended, this);\n        this.state = GroupCallState.Ended;\n\n        if (emitStateEvent) {\n            const existingStateEvent = this.room.currentState.getStateEvents(\n                EventType.GroupCallPrefix,\n                this.groupCallId,\n            )!;\n\n            await this.client.sendStateEvent(\n                this.room.roomId,\n                EventType.GroupCallPrefix,\n                {\n                    ...existingStateEvent.getContent(),\n                    \"m.terminated\": GroupCallTerminationReason.CallEnded,\n                },\n                this.groupCallId,\n            );\n        }\n    }\n\n    /*\n     * Local Usermedia\n     */\n\n    public isLocalVideoMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isVideoMuted();\n        }\n\n        return true;\n    }\n\n    public isMicrophoneMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isAudioMuted();\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's microphone.\n     * @param muted - Whether to mute the microphone\n     * @returns Whether muting/unmuting was successful\n     */\n    public async setMicrophoneMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !(await this.client.getMediaHandler().hasAudioDevice())) {\n            return false;\n        }\n\n        const sendUpdatesBefore = !muted && this.isPtt;\n\n        // set a timer for the maximum transmit time on PTT calls\n        if (this.isPtt) {\n            // Set or clear the max transmit timer\n            if (!muted && this.isMicrophoneMuted()) {\n                this.transmitTimer = setTimeout(() => {\n                    this.setMicrophoneMuted(true);\n                }, this.pttMaxTransmitTime);\n            } else if (muted && !this.isMicrophoneMuted()) {\n                if (this.transmitTimer !== null) clearTimeout(this.transmitTimer);\n                this.transmitTimer = null;\n            }\n        }\n\n        this.forEachCall((call) => call.localUsermediaFeed?.setAudioVideoMuted(muted, null));\n\n        const sendUpdates = async (): Promise<void> => {\n            const updates: Promise<void>[] = [];\n            this.forEachCall((call) => updates.push(call.sendMetadataUpdate()));\n\n            await Promise.all(updates).catch((e) =>\n                logger.info(\n                    `GroupCall ${this.groupCallId} setMicrophoneMuted() failed to send some metadata updates`,\n                    e,\n                ),\n            );\n        };\n\n        if (sendUpdatesBefore) await sendUpdates();\n\n        if (this.localCallFeed) {\n            logger.log(\n                `GroupCall ${this.groupCallId} setMicrophoneMuted() (streamId=${this.localCallFeed.stream.id}, muted=${muted})`,\n            );\n\n            // We needed this here to avoid an error in case user join a call without a device.\n            // I can not use .then .catch functions because linter :-(\n            try {\n                if (!muted) {\n                    const stream = await this.client\n                        .getMediaHandler()\n                        .getUserMediaStream(true, !this.localCallFeed.isVideoMuted());\n                    if (stream === null) {\n                        // if case permission denied to get a stream stop this here\n                        /* istanbul ignore next */\n                        logger.log(\n                            `GroupCall ${this.groupCallId} setMicrophoneMuted() no device to receive local stream, muted=${muted}`,\n                        );\n                        return false;\n                    }\n                }\n            } catch (e) {\n                /* istanbul ignore next */\n                logger.log(\n                    `GroupCall ${this.groupCallId} setMicrophoneMuted() no device or permission to receive local stream, muted=${muted}`,\n                );\n                return false;\n            }\n\n            this.localCallFeed.setAudioVideoMuted(muted, null);\n            // I don't believe its actually necessary to enable these tracks: they\n            // are the one on the GroupCall's own CallFeed and are cloned before being\n            // given to any of the actual calls, so these tracks don't actually go\n            // anywhere. Let's do it anyway to avoid confusion.\n            setTracksEnabled(this.localCallFeed.stream.getAudioTracks(), !muted);\n        } else {\n            logger.log(`GroupCall ${this.groupCallId} setMicrophoneMuted() no stream muted (muted=${muted})`);\n            this.initWithAudioMuted = muted;\n        }\n\n        this.forEachCall((call) =>\n            setTracksEnabled(call.localUsermediaFeed!.stream.getAudioTracks(), !muted && this.callExpected(call)),\n        );\n        this.emit(GroupCallEvent.LocalMuteStateChanged, muted, this.isLocalVideoMuted());\n\n        if (!sendUpdatesBefore) await sendUpdates();\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's video.\n     * @param muted - Whether to mute the video\n     * @returns Whether muting/unmuting was successful\n     */\n    public async setLocalVideoMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !(await this.client.getMediaHandler().hasVideoDevice())) {\n            return false;\n        }\n\n        if (this.localCallFeed) {\n            /* istanbul ignore next */\n            logger.log(\n                `GroupCall ${this.groupCallId} setLocalVideoMuted() (stream=${this.localCallFeed.stream.id}, muted=${muted})`,\n            );\n\n            try {\n                const stream = await this.client.getMediaHandler().getUserMediaStream(true, !muted);\n                await this.updateLocalUsermediaStream(stream);\n                this.localCallFeed.setAudioVideoMuted(null, muted);\n                setTracksEnabled(this.localCallFeed.stream.getVideoTracks(), !muted);\n            } catch (_) {\n                // No permission to video device\n                /* istanbul ignore next */\n                logger.log(\n                    `GroupCall ${this.groupCallId} setLocalVideoMuted() no device or permission to receive local stream, muted=${muted}`,\n                );\n                return false;\n            }\n        } else {\n            logger.log(`GroupCall ${this.groupCallId} setLocalVideoMuted() no stream muted (muted=${muted})`);\n            this.initWithVideoMuted = muted;\n        }\n\n        const updates: Promise<unknown>[] = [];\n        this.forEachCall((call) => updates.push(call.setLocalVideoMuted(muted)));\n        await Promise.all(updates);\n\n        // We setTracksEnabled again, independently from the call doing it\n        // internally, since we might not be expecting the call\n        this.forEachCall((call) =>\n            setTracksEnabled(call.localUsermediaFeed!.stream.getVideoTracks(), !muted && this.callExpected(call)),\n        );\n\n        this.emit(GroupCallEvent.LocalMuteStateChanged, this.isMicrophoneMuted(), muted);\n\n        return true;\n    }\n\n    public async setScreensharingEnabled(enabled: boolean, opts: IScreensharingOpts = {}): Promise<boolean> {\n        if (enabled === this.isScreensharing()) {\n            return enabled;\n        }\n\n        if (enabled) {\n            try {\n                logger.log(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() is asking for screensharing permissions`,\n                );\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n\n                for (const track of stream.getTracks()) {\n                    const onTrackEnded = (): void => {\n                        this.setScreensharingEnabled(false);\n                        track.removeEventListener(\"ended\", onTrackEnded);\n                    };\n\n                    track.addEventListener(\"ended\", onTrackEnded);\n                }\n\n                logger.log(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() granted screensharing permissions. Setting screensharing enabled on all calls`,\n                );\n\n                this.localDesktopCapturerSourceId = opts.desktopCapturerSourceId;\n                this.localScreenshareFeed = new CallFeed({\n                    client: this.client,\n                    roomId: this.room.roomId,\n                    userId: this.client.getUserId()!,\n                    deviceId: this.client.getDeviceId()!,\n                    stream,\n                    purpose: SDPStreamMetadataPurpose.Screenshare,\n                    audioMuted: false,\n                    videoMuted: false,\n                });\n                this.addScreenshareFeed(this.localScreenshareFeed);\n\n                this.emit(\n                    GroupCallEvent.LocalScreenshareStateChanged,\n                    true,\n                    this.localScreenshareFeed,\n                    this.localDesktopCapturerSourceId,\n                );\n\n                // TODO: handle errors\n                this.forEachCall((call) => call.pushLocalFeed(this.localScreenshareFeed!.clone()));\n\n                return true;\n            } catch (error) {\n                if (opts.throwOnFail) throw error;\n                logger.error(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() enabling screensharing error`,\n                    error,\n                );\n                this.emit(\n                    GroupCallEvent.Error,\n                    new GroupCallError(\n                        GroupCallErrorCode.NoUserMedia,\n                        \"Failed to get screen-sharing stream: \",\n                        error as Error,\n                    ),\n                );\n                return false;\n            }\n        } else {\n            this.forEachCall((call) => {\n                if (call.localScreensharingFeed) call.removeLocalFeed(call.localScreensharingFeed);\n            });\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed!.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed!);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n            this.emit(GroupCallEvent.LocalScreenshareStateChanged, false, undefined, undefined);\n            return false;\n        }\n    }\n\n    public isScreensharing(): boolean {\n        return !!this.localScreenshareFeed;\n    }\n\n    /*\n     * Call Setup\n     *\n     * There are two different paths for calls to be created:\n     * 1. Incoming calls triggered by the Call.incoming event.\n     * 2. Outgoing calls to the initial members of a room or new members\n     *    as they are observed by the RoomState.members event.\n     */\n\n    private onIncomingCall = (newCall: MatrixCall): void => {\n        // The incoming calls may be for another room, which we will ignore.\n        if (newCall.roomId !== this.room.roomId) {\n            return;\n        }\n\n        if (newCall.state !== CallState.Ringing) {\n            logger.warn(\n                `GroupCall ${this.groupCallId} onIncomingCall() incoming call no longer in ringing state - ignoring`,\n            );\n            return;\n        }\n\n        if (!newCall.groupCallId || newCall.groupCallId !== this.groupCallId) {\n            logger.log(\n                `GroupCall ${this.groupCallId} onIncomingCall() ignored because it doesn't match the current group call`,\n            );\n            newCall.reject();\n            return;\n        }\n\n        const opponentUserId = newCall.getOpponentMember()?.userId;\n        if (opponentUserId === undefined) {\n            logger.warn(`GroupCall ${this.groupCallId} onIncomingCall() incoming call with no member - ignoring`);\n            return;\n        }\n\n        const deviceMap = this.calls.get(opponentUserId) ?? new Map<string, MatrixCall>();\n        const prevCall = deviceMap.get(newCall.getOpponentDeviceId()!);\n\n        if (prevCall?.callId === newCall.callId) return;\n\n        logger.log(\n            `GroupCall ${this.groupCallId} onIncomingCall() incoming call (userId=${opponentUserId}, callId=${newCall.callId})`,\n        );\n\n        if (prevCall) prevCall.hangup(CallErrorCode.Replaced, false);\n\n        this.initCall(newCall);\n\n        const feeds = this.getLocalFeeds().map((feed) => feed.clone());\n        if (!this.callExpected(newCall)) {\n            // Disable our tracks for users not explicitly participating in the\n            // call but trying to receive the feeds\n            for (const feed of feeds) {\n                setTracksEnabled(feed.stream.getAudioTracks(), false);\n                setTracksEnabled(feed.stream.getVideoTracks(), false);\n            }\n        }\n        newCall.answerWithCallFeeds(feeds);\n\n        deviceMap.set(newCall.getOpponentDeviceId()!, newCall);\n        this.calls.set(opponentUserId, deviceMap);\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /**\n     * Determines whether a given participant expects us to call them (versus\n     * them calling us).\n     * @param userId - The participant's user ID.\n     * @param deviceId - The participant's device ID.\n     * @returns Whether we need to place an outgoing call to the participant.\n     */\n    private wantsOutgoingCall(userId: string, deviceId: string): boolean {\n        const localUserId = this.client.getUserId()!;\n        const localDeviceId = this.client.getDeviceId()!;\n        return (\n            // If a user's ID is less than our own, they'll call us\n            userId >= localUserId &&\n            // If this is another one of our devices, compare device IDs to tell whether it'll call us\n            (userId !== localUserId || deviceId > localDeviceId)\n        );\n    }\n\n    /**\n     * Places calls to all participants that we're responsible for calling.\n     */\n    private placeOutgoingCalls(): void {\n        let callsChanged = false;\n\n        for (const [{ userId }, participantMap] of this.participants) {\n            const callMap = this.calls.get(userId) ?? new Map<string, MatrixCall>();\n\n            for (const [deviceId, participant] of participantMap) {\n                const prevCall = callMap.get(deviceId);\n\n                if (\n                    prevCall?.getOpponentSessionId() !== participant.sessionId &&\n                    this.wantsOutgoingCall(userId, deviceId)\n                ) {\n                    callsChanged = true;\n\n                    if (prevCall !== undefined) {\n                        logger.debug(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() replacing call (userId=${userId}, deviceId=${deviceId}, callId=${prevCall.callId})`,\n                        );\n                        prevCall.hangup(CallErrorCode.NewSession, false);\n                    }\n\n                    const newCall = createNewMatrixCall(this.client, this.room.roomId, {\n                        invitee: userId,\n                        opponentDeviceId: deviceId,\n                        opponentSessionId: participant.sessionId,\n                        groupCallId: this.groupCallId,\n                    });\n\n                    if (newCall === null) {\n                        logger.error(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() failed to create call (userId=${userId}, device=${deviceId})`,\n                        );\n                        callMap.delete(deviceId);\n                    } else {\n                        this.initCall(newCall);\n                        callMap.set(deviceId, newCall);\n\n                        logger.debug(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() placing call (userId=${userId}, deviceId=${deviceId}, sessionId=${participant.sessionId})`,\n                        );\n\n                        newCall\n                            .placeCallWithCallFeeds(\n                                this.getLocalFeeds().map((feed) => feed.clone()),\n                                participant.screensharing,\n                            )\n                            .then(() => {\n                                if (this.dataChannelsEnabled) {\n                                    newCall.createDataChannel(\"datachannel\", this.dataChannelOptions);\n                                }\n                            })\n                            .catch((e) => {\n                                logger.warn(\n                                    `GroupCall ${this.groupCallId} placeOutgoingCalls() failed to place call (userId=${userId})`,\n                                    e,\n                                );\n\n                                if (e instanceof CallError && e.code === GroupCallErrorCode.UnknownDevice) {\n                                    this.emit(GroupCallEvent.Error, e);\n                                } else {\n                                    this.emit(\n                                        GroupCallEvent.Error,\n                                        new GroupCallError(\n                                            GroupCallErrorCode.PlaceCallFailed,\n                                            `Failed to place call to ${userId}`,\n                                        ),\n                                    );\n                                }\n\n                                newCall.hangup(CallErrorCode.SignallingFailed, false);\n                                if (callMap.get(deviceId) === newCall) callMap.delete(deviceId);\n                            });\n                    }\n                }\n            }\n\n            if (callMap.size > 0) {\n                this.calls.set(userId, callMap);\n            } else {\n                this.calls.delete(userId);\n            }\n        }\n\n        if (callsChanged) this.emit(GroupCallEvent.CallsChanged, this.calls);\n    }\n\n    /*\n     * Room Member State\n     */\n\n    private getMemberStateEvents(): MatrixEvent[];\n    private getMemberStateEvents(userId: string): MatrixEvent | null;\n    private getMemberStateEvents(userId?: string): MatrixEvent[] | MatrixEvent | null {\n        return userId === undefined\n            ? this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix)\n            : this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix, userId);\n    }\n\n    private onRetryCallLoop = (): void => {\n        let needsRetry = false;\n\n        for (const [{ userId }, participantMap] of this.participants) {\n            const callMap = this.calls.get(userId);\n            let retriesMap = this.retryCallCounts.get(userId);\n\n            for (const [deviceId, participant] of participantMap) {\n                const call = callMap?.get(deviceId);\n                const retries = retriesMap?.get(deviceId) ?? 0;\n\n                if (\n                    call?.getOpponentSessionId() !== participant.sessionId &&\n                    this.wantsOutgoingCall(userId, deviceId) &&\n                    retries < 3\n                ) {\n                    if (retriesMap === undefined) {\n                        retriesMap = new Map();\n                        this.retryCallCounts.set(userId, retriesMap);\n                    }\n                    retriesMap.set(deviceId, retries + 1);\n                    needsRetry = true;\n                }\n            }\n        }\n\n        if (needsRetry) this.placeOutgoingCalls();\n    };\n\n    private initCall(call: MatrixCall): void {\n        const opponentMemberId = getCallUserId(call);\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot init call without user id\");\n        }\n\n        const onCallFeedsChanged = (): void => this.onCallFeedsChanged(call);\n        const onCallStateChanged = (state: CallState, oldState?: CallState): void =>\n            this.onCallStateChanged(call, state, oldState);\n        const onCallHangup = this.onCallHangup;\n        const onCallReplaced = (newCall: MatrixCall): void => this.onCallReplaced(call, newCall);\n\n        let deviceMap = this.callHandlers.get(opponentMemberId);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.callHandlers.set(opponentMemberId, deviceMap);\n        }\n\n        deviceMap.set(call.getOpponentDeviceId()!, {\n            onCallFeedsChanged,\n            onCallStateChanged,\n            onCallHangup,\n            onCallReplaced,\n        });\n\n        call.on(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.on(CallEvent.State, onCallStateChanged);\n        call.on(CallEvent.Hangup, onCallHangup);\n        call.on(CallEvent.Replaced, onCallReplaced);\n\n        call.isPtt = this.isPtt;\n\n        this.reEmitter.reEmit(call, Object.values(CallEvent));\n\n        call.initStats(this.stats);\n\n        onCallFeedsChanged();\n    }\n\n    private disposeCall(call: MatrixCall, hangupReason: CallErrorCode): void {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot dispose call without user id\");\n        }\n\n        const deviceMap = this.callHandlers.get(opponentMemberId)!;\n        const { onCallFeedsChanged, onCallStateChanged, onCallHangup, onCallReplaced } =\n            deviceMap.get(opponentDeviceId)!;\n\n        call.removeListener(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.removeListener(CallEvent.State, onCallStateChanged);\n        call.removeListener(CallEvent.Hangup, onCallHangup);\n        call.removeListener(CallEvent.Replaced, onCallReplaced);\n\n        deviceMap.delete(opponentMemberId);\n        if (deviceMap.size === 0) this.callHandlers.delete(opponentMemberId);\n\n        if (call.hangupReason === CallErrorCode.Replaced) {\n            return;\n        }\n\n        const usermediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n\n        if (usermediaFeed) {\n            this.removeUserMediaFeed(usermediaFeed);\n        }\n\n        const screenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n\n        if (screenshareFeed) {\n            this.removeScreenshareFeed(screenshareFeed);\n        }\n    }\n\n    private onCallFeedsChanged = (call: MatrixCall): void => {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot change call feeds without user id\");\n        }\n\n        const currentUserMediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n        const remoteUsermediaFeed = call.remoteUsermediaFeed;\n        const remoteFeedChanged = remoteUsermediaFeed !== currentUserMediaFeed;\n\n        if (remoteFeedChanged) {\n            if (!currentUserMediaFeed && remoteUsermediaFeed) {\n                this.addUserMediaFeed(remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && remoteUsermediaFeed) {\n                this.replaceUserMediaFeed(currentUserMediaFeed, remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && !remoteUsermediaFeed) {\n                this.removeUserMediaFeed(currentUserMediaFeed);\n            }\n        }\n\n        const currentScreenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n        const remoteScreensharingFeed = call.remoteScreensharingFeed;\n        const remoteScreenshareFeedChanged = remoteScreensharingFeed !== currentScreenshareFeed;\n\n        if (remoteScreenshareFeedChanged) {\n            if (!currentScreenshareFeed && remoteScreensharingFeed) {\n                this.addScreenshareFeed(remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && remoteScreensharingFeed) {\n                this.replaceScreenshareFeed(currentScreenshareFeed, remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && !remoteScreensharingFeed) {\n                this.removeScreenshareFeed(currentScreenshareFeed);\n            }\n        }\n    };\n\n    private onCallStateChanged = (call: MatrixCall, state: CallState, _oldState: CallState | undefined): void => {\n        if (state === CallState.Ended) return;\n\n        const audioMuted = this.localCallFeed!.isAudioMuted();\n\n        if (call.localUsermediaStream && call.isMicrophoneMuted() !== audioMuted) {\n            call.setMicrophoneMuted(audioMuted);\n        }\n\n        const videoMuted = this.localCallFeed!.isVideoMuted();\n\n        if (call.localUsermediaStream && call.isLocalVideoMuted() !== videoMuted) {\n            call.setLocalVideoMuted(videoMuted);\n        }\n\n        const opponentUserId = call.getOpponentMember()?.userId;\n        if (state === CallState.Connected && opponentUserId) {\n            const retriesMap = this.retryCallCounts.get(opponentUserId);\n            retriesMap?.delete(call.getOpponentDeviceId()!);\n            if (retriesMap?.size === 0) this.retryCallCounts.delete(opponentUserId);\n        }\n    };\n\n    private onCallHangup = (call: MatrixCall): void => {\n        if (call.hangupReason === CallErrorCode.Replaced) return;\n\n        const opponentUserId = call.getOpponentMember()?.userId ?? this.room.getMember(call.invitee!)!.userId;\n        const deviceMap = this.calls.get(opponentUserId);\n\n        // Sanity check that this call is in fact in the map\n        if (deviceMap?.get(call.getOpponentDeviceId()!) === call) {\n            this.disposeCall(call, call.hangupReason as CallErrorCode);\n            deviceMap.delete(call.getOpponentDeviceId()!);\n            if (deviceMap.size === 0) this.calls.delete(opponentUserId);\n            this.emit(GroupCallEvent.CallsChanged, this.calls);\n        }\n    };\n\n    private onCallReplaced = (prevCall: MatrixCall, newCall: MatrixCall): void => {\n        const opponentUserId = prevCall.getOpponentMember()!.userId;\n\n        let deviceMap = this.calls.get(opponentUserId);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.calls.set(opponentUserId, deviceMap);\n        }\n\n        prevCall.hangup(CallErrorCode.Replaced, false);\n        this.initCall(newCall);\n        deviceMap.set(prevCall.getOpponentDeviceId()!, newCall);\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /*\n     * UserMedia CallFeed Event Handlers\n     */\n\n    public getUserMediaFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.userMediaFeeds.find((f) => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addUserMediaFeed(callFeed: CallFeed): void {\n        this.userMediaFeeds.push(callFeed);\n        callFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private replaceUserMediaFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            (f) => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to replace\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        replacementFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private removeUserMediaFeed(callFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            (f) => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to remove\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n\n        if (this.activeSpeaker === callFeed) {\n            this.activeSpeaker = this.userMediaFeeds[0];\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    }\n\n    private onActiveSpeakerLoop = (): void => {\n        let topAvg: number | undefined = undefined;\n        let nextActiveSpeaker: CallFeed | undefined = undefined;\n\n        for (const callFeed of this.userMediaFeeds) {\n            if (callFeed.isLocal() && this.userMediaFeeds.length > 1) continue;\n\n            const total = callFeed.speakingVolumeSamples.reduce(\n                (acc, volume) => acc + Math.max(volume, SPEAKING_THRESHOLD),\n            );\n            const avg = total / callFeed.speakingVolumeSamples.length;\n\n            if (!topAvg || avg > topAvg) {\n                topAvg = avg;\n                nextActiveSpeaker = callFeed;\n            }\n        }\n\n        if (nextActiveSpeaker && this.activeSpeaker !== nextActiveSpeaker && topAvg && topAvg > SPEAKING_THRESHOLD) {\n            this.activeSpeaker = nextActiveSpeaker;\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    };\n\n    /*\n     * Screenshare Call Feed Event Handlers\n     */\n\n    public getScreenshareFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.screenshareFeeds.find((f) => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addScreenshareFeed(callFeed: CallFeed): void {\n        this.screenshareFeeds.push(callFeed);\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private replaceScreenshareFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            (f) => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to replace\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private removeScreenshareFeed(callFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            (f) => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to remove\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    /**\n     * Recalculates and updates the participant map to match the room state.\n     */\n    private updateParticipants(): void {\n        const localMember = this.room.getMember(this.client.getUserId()!)!;\n        if (!localMember) {\n            // The client hasn't fetched enough of the room state to get our own member\n            // event. This probably shouldn't happen, but sanity check & exit for now.\n            logger.warn(\n                `GroupCall ${this.groupCallId} updateParticipants() tried to update participants before local room member is available`,\n            );\n            return;\n        }\n\n        if (this.participantsExpirationTimer !== null) {\n            clearTimeout(this.participantsExpirationTimer);\n            this.participantsExpirationTimer = null;\n        }\n\n        if (this.state === GroupCallState.Ended) {\n            this.participants = new Map();\n            return;\n        }\n\n        const participants = new Map<RoomMember, Map<string, ParticipantState>>();\n        const now = Date.now();\n        const entered = this.state === GroupCallState.Entered || this.enteredViaAnotherSession;\n        let nextExpiration = Infinity;\n\n        for (const e of this.getMemberStateEvents()) {\n            const member = this.room.getMember(e.getStateKey()!);\n            const content = e.getContent<Record<any, unknown>>();\n            const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n            const call = calls.find((call) => call[\"m.call_id\"] === this.groupCallId);\n            const devices: Record<any, unknown>[] = Array.isArray(call?.[\"m.devices\"]) ? call![\"m.devices\"] : [];\n\n            // Filter out invalid and expired devices\n            let validDevices = devices.filter(\n                (d) =>\n                    typeof d.device_id === \"string\" &&\n                    typeof d.session_id === \"string\" &&\n                    typeof d.expires_ts === \"number\" &&\n                    d.expires_ts > now &&\n                    Array.isArray(d.feeds),\n            ) as unknown as IGroupCallRoomMemberDevice[];\n\n            // Apply local echo for the unentered case\n            if (!entered && member?.userId === this.client.getUserId()!) {\n                validDevices = validDevices.filter((d) => d.device_id !== this.client.getDeviceId()!);\n            }\n\n            // Must have a connected device and be joined to the room\n            if (validDevices.length > 0 && member?.membership === \"join\") {\n                const deviceMap = new Map<string, ParticipantState>();\n                participants.set(member, deviceMap);\n\n                for (const d of validDevices) {\n                    deviceMap.set(d.device_id, {\n                        sessionId: d.session_id,\n                        screensharing: d.feeds.some((f) => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                    });\n                    if (d.expires_ts < nextExpiration) nextExpiration = d.expires_ts;\n                }\n            }\n        }\n\n        // Apply local echo for the entered case\n        if (entered) {\n            let deviceMap = participants.get(localMember);\n            if (deviceMap === undefined) {\n                deviceMap = new Map();\n                participants.set(localMember, deviceMap);\n            }\n\n            if (!deviceMap.has(this.client.getDeviceId()!)) {\n                deviceMap.set(this.client.getDeviceId()!, {\n                    sessionId: this.client.getSessionId(),\n                    screensharing: this.getLocalFeeds().some((f) => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                });\n            }\n        }\n\n        this.participants = participants;\n        if (nextExpiration < Infinity) {\n            this.participantsExpirationTimer = setTimeout(() => this.updateParticipants(), nextExpiration - now);\n        }\n    }\n\n    /**\n     * Updates the local user's member state with the devices returned by the given function.\n     * @param fn - A function from the current devices to the new devices. If it\n     *   returns null, the update will be skipped.\n     * @param keepAlive - Whether the request should outlive the window.\n     */\n    private async updateDevices(\n        fn: (devices: IGroupCallRoomMemberDevice[]) => IGroupCallRoomMemberDevice[] | null,\n        keepAlive = false,\n    ): Promise<void> {\n        const now = Date.now();\n        const localUserId = this.client.getUserId()!;\n\n        const event = this.getMemberStateEvents(localUserId);\n        const content = event?.getContent<Record<any, unknown>>() ?? {};\n        const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n\n        let call: Record<any, unknown> | null = null;\n        const otherCalls: Record<any, unknown>[] = [];\n        for (const c of calls) {\n            if (c[\"m.call_id\"] === this.groupCallId) {\n                call = c;\n            } else {\n                otherCalls.push(c);\n            }\n        }\n        if (call === null) call = {};\n\n        const devices: Record<any, unknown>[] = Array.isArray(call[\"m.devices\"]) ? call[\"m.devices\"] : [];\n\n        // Filter out invalid and expired devices\n        const validDevices = devices.filter(\n            (d) =>\n                typeof d.device_id === \"string\" &&\n                typeof d.session_id === \"string\" &&\n                typeof d.expires_ts === \"number\" &&\n                d.expires_ts > now &&\n                Array.isArray(d.feeds),\n        ) as unknown as IGroupCallRoomMemberDevice[];\n\n        const newDevices = fn(validDevices);\n        if (newDevices === null) return;\n\n        const newCalls = [...(otherCalls as unknown as IGroupCallRoomMemberCallState[])];\n        if (newDevices.length > 0) {\n            newCalls.push({\n                ...call,\n                \"m.call_id\": this.groupCallId,\n                \"m.devices\": newDevices,\n            });\n        }\n\n        const newContent: IGroupCallRoomMemberState = { \"m.calls\": newCalls };\n\n        await this.client.sendStateEvent(this.room.roomId, EventType.GroupCallMemberPrefix, newContent, localUserId, {\n            keepAlive,\n        });\n    }\n\n    private async addDeviceToMemberState(): Promise<void> {\n        await this.updateDevices((devices) => [\n            ...devices.filter((d) => d.device_id !== this.client.getDeviceId()!),\n            {\n                device_id: this.client.getDeviceId()!,\n                session_id: this.client.getSessionId(),\n                expires_ts: Date.now() + DEVICE_TIMEOUT,\n                feeds: this.getLocalFeeds().map((feed) => ({ purpose: feed.purpose })),\n                // TODO: Add data channels\n            },\n        ]);\n    }\n\n    private async updateMemberState(): Promise<void> {\n        // Clear the old update interval before proceeding\n        if (this.resendMemberStateTimer !== null) {\n            clearInterval(this.resendMemberStateTimer);\n            this.resendMemberStateTimer = null;\n        }\n\n        if (this.state === GroupCallState.Entered) {\n            // Add the local device\n            await this.addDeviceToMemberState();\n\n            // Resend the state event every so often so it doesn't become stale\n            this.resendMemberStateTimer = setInterval(async () => {\n                logger.log(`GroupCall ${this.groupCallId} updateMemberState() resending call member state\"`);\n                try {\n                    await this.addDeviceToMemberState();\n                } catch (e) {\n                    logger.error(\n                        `GroupCall ${this.groupCallId} updateMemberState() failed to resend call member state`,\n                        e,\n                    );\n                }\n            }, (DEVICE_TIMEOUT * 3) / 4);\n        } else {\n            // Remove the local device\n            await this.updateDevices(\n                (devices) => devices.filter((d) => d.device_id !== this.client.getDeviceId()!),\n                true,\n            );\n        }\n    }\n\n    /**\n     * Cleans up our member state by filtering out logged out devices, inactive\n     * devices, and our own device (if we know we haven't entered).\n     */\n    public async cleanMemberState(): Promise<void> {\n        const { devices: myDevices } = await this.client.getDevices();\n        const deviceMap = new Map<string, IMyDevice>(myDevices.map((d) => [d.device_id, d]));\n\n        // updateDevices takes care of filtering out inactive devices for us\n        await this.updateDevices((devices) => {\n            const newDevices = devices.filter((d) => {\n                const device = deviceMap.get(d.device_id);\n                return (\n                    device?.last_seen_ts !== undefined &&\n                    !(\n                        d.device_id === this.client.getDeviceId()! &&\n                        this.state !== GroupCallState.Entered &&\n                        !this.enteredViaAnotherSession\n                    )\n                );\n            });\n\n            // Skip the update if the devices are unchanged\n            return newDevices.length === devices.length ? null : newDevices;\n        });\n    }\n\n    private onRoomState = (): void => this.updateParticipants();\n\n    private onParticipantsChanged = (): void => {\n        // Re-run setTracksEnabled on all calls, so that participants that just\n        // left get denied access to our media, and participants that just\n        // joined get granted access\n        this.forEachCall((call) => {\n            const expected = this.callExpected(call);\n            for (const feed of call.getLocalFeeds()) {\n                setTracksEnabled(feed.stream.getAudioTracks(), !feed.isAudioMuted() && expected);\n                setTracksEnabled(feed.stream.getVideoTracks(), !feed.isVideoMuted() && expected);\n            }\n        });\n\n        if (this.state === GroupCallState.Entered) this.placeOutgoingCalls();\n    };\n\n    private onStateChanged = (newState: GroupCallState, oldState: GroupCallState): void => {\n        if (\n            newState === GroupCallState.Entered ||\n            oldState === GroupCallState.Entered ||\n            newState === GroupCallState.Ended\n        ) {\n            // We either entered, left, or ended the call\n            this.updateParticipants();\n            this.updateMemberState().catch((e) =>\n                logger.error(\n                    `GroupCall ${this.groupCallId} onStateChanged() failed to update member state devices\"`,\n                    e,\n                ),\n            );\n        }\n    };\n\n    private onLocalFeedsChanged = (): void => {\n        if (this.state === GroupCallState.Entered) {\n            this.updateMemberState().catch((e) =>\n                logger.error(\n                    `GroupCall ${this.groupCallId} onLocalFeedsChanged() failed to update member state feeds`,\n                    e,\n                ),\n            );\n        }\n    };\n\n    public getGroupCallStats(): GroupCallStats {\n        return this.stats;\n    }\n}\n"],"mappings":"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"}